<?php
/**
 * @file
 * Code for the Collabco Groups Feature feature.
 */

include_once 'collabco_groups_feature.features.inc';
include_once 'collabco_groups_feature.inc';

/**
 * Implements hook_menu().
 */
function collabco_groups_feature_menu() {
  $items['node/%/taxonomy/%/add'] = array(
    'page callback' => 'collabco_groups_feature_term_add_page',
    'page arguments' => array(3),
    'access callback' => 'collabco_groups_feature_term_add_access',
    'access arguments' => array(3),
  );
  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function collabco_groups_feature_menu_alter(&$items) {
  unset($items['node/%node/view']['title']);
  $items['node/%node/view']['title callback'] = 'collabco_groups_feature_set_view_tab_title';
  $items['node/%node/view']['title arguments'] = array(1);
}

/**
 * Menu callback to set group tab title for nodes.
 *
 * @return string
 */
function collabco_groups_feature_set_view_tab_title($node) {
  if (og_is_group('node',$node->nid)) {
    return t('About');
  }
  return t('View');
}

/**
 * Menu callback to check access permission to term add page.
 *
 * @return bool
 */
function collabco_groups_feature_term_add_access($bundle) {
  if ($vocabulary = taxonomy_vocabulary_machine_name_load($bundle)) {
    $perm_string = "edit terms in " .  $vocabulary->vid;
    return user_access($perm_string);
  }
  else {
    return TRUE;
  }
}
/**
 * Menu callback to provide users with a term add page.
 *
 * @return array
 *   A Drupal build array.
 */
function collabco_groups_feature_term_add_page($bundle) {
  if ($vocabulary = taxonomy_vocabulary_machine_name_load($bundle)) {
    module_load_include('inc', 'taxonomy', 'taxonomy.admin');
    //Build taxonomy form.
    drupal_set_title($title = t('Add ') . $vocabulary->name, $output = CHECK_PLAIN);
    $form_id = 'taxonomy_form_term';
    $edit = array();
    $form = drupal_get_form($form_id, $edit, $vocabulary);
    return drupal_render($form);
  }
  else {
    return MENU_NOT_FOUND;
  }
}

/**
 * Implements hook_init().
 * 
 * Set og context from url query, if its being used with entity prepopulate.
 */
function collabco_groups_feature_init() { 
  $params = drupal_get_query_parameters();
  if (!empty($params[OG_AUDIENCE_FIELD])) {
    $group = node_load($params[OG_AUDIENCE_FIELD]);
    og_context('node', $group);
  }
  // Add OG Context for all subpaths of nodes that are groups.
  // Some ugly code to get the group id from path and set og_context.
  // @todo find a better way to do this, why is there no nicer drupal function?? 
  // why dosn't OG do this by default?
 
  // Check if the current path starts with /node/*.
  if ((arg(0) === 'node') && is_numeric(arg(1))) {
    // Load the node from the current path.
    if ($group = node_load(arg(1))) {
      // Check if this is a group node.
      if (!empty($group->{OG_GROUP_FIELD}['und'][0]['value'])) {
        if ($group->{OG_GROUP_FIELD}['und'][0]['value'] === '1') {
        // Set the og context to the group node from the path.
          og_context('node', $group);
        }
      }
    }
  }
}

/**
 * Implements hook_block_info().
 */
function collabco_groups_feature_block_info() {
  $blocks = array(
    'group_toolbar' => array(
      'info' => t('Group Toolbar'),
    ),
    'group_header' => array(
      'info' => t('Group Header'),
    ),
    'user_groups_list' => array(
      'info' => t('User Groups List'),
    ),
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function collabco_groups_feature_block_view($delta='') {
  global $base_url;
  switch($delta) {
    case 'group_toolbar' :
      $block = collabco_groups_feature_build_group_toolbar_block();
      return $block;
    case 'group_header' :
      $block = collabco_groups_feature_build_group_header_block();
      return $block;
    case 'user_groups_list' :
      $block = collabco_groups_feature_build_user_groups_list_block();
      return $block;
  }
} 

/**
 * Build a group list.
 *
 * @return array
 *   A Drupal build array.
 */
function collabco_groups_feature_build_user_groups_list() {
  global $base_url;
  global $user;

  // Build groups list renderable array.
  $group_links = array();
  $groups = og_get_groups_by_user($user);
  if (!empty($groups)) {
    $list = array(
      '#theme' => 'item_list',
    );
    foreach ($groups['node'] as $key => $gid) {
      $node = node_load($gid);
      $url ='node/' . $node->nid; 
      $list['#items'][$node->nid] = l($node->title, $url);
    }
  }
  return $list;
} 

/**
 * Build a group list block.
 *
 * @return array
 *   A Drupal build array.
 */
function collabco_groups_feature_build_user_groups_list_block() {
  $block = array();
  $links = collabco_groups_feature_build_user_groups_list(); 

  if (empty($links)) { 
    return;
  }
  // Build groups section.
  if (!empty($groups)) {
    $block['content'] = array(
      '#type' => 'container',
      '#attributes' => array('class' => array('group-list')),
      'title' => array(
        '#type' => 'markup',
        '#markup' => 'Your Groups',
        '#weight' => -2,
        '#prefix' => '<h5>',
        '#suffix' => '</h5>'
      ),
      'group_list' => $links,
    );
  }
  return $block;
} 

/**
 * Build a group toolbar block.
 *
 * @return array
 *   A Drupal build array.
 */
function collabco_groups_feature_build_group_toolbar_block() {
  global $user;

  // Check if the current user is in the current group from context.
  $group = og_context();
  $entity_type = 'user';
  if (empty($group) or !og_is_member($group['group_type'], $group['gid'], $entity_type, $user)) {
    return;
  }
  $block['og_context'] = $group;

  // Create list of links for each node type that the user can add to the group. 
  $group_field_info = field_info_field(OG_AUDIENCE_FIELD);
  if (!empty($group_field_info)) {
    // Build render array structure.
    $node_links = collabco_groups_feature_build_node_links($group_field_info['bundles']['node'], $group['gid']);
    $term_links = collabco_groups_feature_build_term_links($group_field_info['bundles']['taxonomy_term'], $group['gid']);
    $block = array();
    $block['content'] = array(
      '#type' => 'container',
      '#attributes' => array('class' => array('group-toolbar')),
      //'content' => array(
        //'#type' => 'markup',
        //'#markup' => t('Add content to this group:'),
        //'#weight' => 0,
      //),
      'add-content-button' => array(
        '#theme' => 'link',
        '#text' => 'Add Content',
        '#path' => '',
        '#options' => array(
          'attributes' => array('title' => 'Add Content', 'class' => array('add-content'), 'data-dropdown' => array('add-content-drop')),
          'html' => FALSE,
        ),
        '#weight' => 1,
      ),
      'add-content-list' => array(
        '#theme' => 'item_list',
        '#attributes' => array('id' => array('add-content-drop'), 'class' => array('f-dropdown')),
        '#weight' => 2,
        '#items' => $node_links,
      ),
      'add-term-list' => array(
        '#theme' => 'item_list',
        '#weight' => 3,
        '#items' => $term_links,
      ),
    );
    return $block;
  }
}

/**
 * Build a group header block.
 *
 * @return array
 *   A Drupal build array.
 */
function collabco_groups_feature_build_group_header_block() {
  $og_context = og_context();
  if (empty($og_context)) {
    return;
  }
  $node = node_load($og_context['gid']);

  // Get group title and all parent group titles.
  $title = collabco_groups_feature_get_title_recursive($node);

  // Determine group privacy status.
  if (!empty($node->{OG_ACCESS_FIELD}['und'][0]['value']) && $node->{OG_ACCESS_FIELD}['und'][0]['value'] === '1') {
    $privacy = t('Private');
  }
  else {
    $privacy = t('Public');
  }

  // Build the description (body) field.
  $description = field_view_field('node', $node, 'body', array(
    'type' => 'text_summary_or_trimmed',
    'label'=>'hidden',
    'settings'=>array('trim_length' => 150),
  ));
  $description['#weight'] = '4';

  // Build the group subscribe field.
  $group_field = field_view_field('node', $node, OG_GROUP_FIELD, array(
    'type' => 'og_group_subscribe',
    'label'=>'hidden',
  ));
  $group_field['#weight'] = '1';

  // Build render array structure.
  $block = array();
  $block['content'] = array(
    '#type' => 'container',
    '#attributes' => array('class' => array('group-header')),
    'title' => array(
      '#type' => 'markup',
      '#markup' => $title,
      '#weight' => 0,
      '#prefix' => '<h1>',
      '#suffix' => '</h1>'
    ),
    'status' => array(
      '#type' => 'markup',
      '#markup' => $privacy,
      '#weight' => 2,
      '#prefix' => '<div class="privacy-status">',
      '#suffix' => '</div>',
    ),
    'description' => $description,
    'group' => $group_field,
  );
  return $block;
}

/**
 * Implements hook_preprocess_page().
 */
function collabco_groups_feature_preprocess_page(&$vars) {
  $vars['show_title'] = TRUE; // so that showtitle is true by default
  //if (isset($vars['node']->{OG_GROUP_FIELD})) {
    //if ($vars['node']->{OG_GROUP_FIELD}['und'][0]['value'] === '1') { 
      $vars['show_title'] = FALSE;
    //}
  //}
}

/**
 * Implements hook_entity_insert().
 * 
 * Add new subgroup gid to group terms.
 */
function collabco_groups_feature_entity_insert($entity,$type) { 
  switch ($type) {
  case 'node':
    collabco_groups_feature_add_parent_terms_to_group($entity,$type);
    break;
  case 'taxonomy_term':
    collabco_groups_feature_add_child_groups_to_entity($entity,$type);
    break;
  }
}

function collabco_groups_feature_add_child_groups_to_entity($entity,$type) { 
  // Recursive function needs an array of gids by entity type.
  $wrapper = entity_metadata_wrapper($type, $entity);
  $gids = array('node' => $wrapper->{OG_AUDIENCE_FIELD}->raw()); 
  $child_gids = collabco_groups_feature_get_children_recursive($gids);
  if (empty($child_gids['node'])) { 
    return;
  }
  $values = array(
    'entity_type' => $type, 
    'entity' => $entity, 
    'field_name' => OG_AUDIENCE_FIELD, 
    'state' => OG_STATE_ACTIVE,
  );
  foreach ($child_gids['node'] as $gid) {
    og_group('node', $gid, $values);
  }
}

/**
 * Implements hook_views_pre_view().
 */
function collabco_groups_feature_views_pre_view($view, $display_id, $args) {
  // Find all Collabco integrations.
  $integrations = module_invoke_all('collabco_integration');
  $views_integration= array();
  foreach ($integrations as $integration) { 
    if (!empty($integration['views'])) {
      $views_integration = array_merge($views_integration, $integration['views']);
    }
  }
  if (!empty($views_integration[$view->name][$display_id]['add_content_link'])) {
    $bundles = $views_integration[$view->name][$display_id]['add_content_link']['bundles'];
    $areas = $views_integration[$view->name][$display_id]['add_content_link']['areas'];
    collabco_groups_feature_views_content_link($view, $display_id, $bundles, $areas);
  }
}

/**
 * Implements hook_collabco_integration().
 */
function collabco_groups_feature_collabco_integration() {
  // Add links to views if a module wants to do that.
  return array(
    'collabco_groups_feature' => array(
      'views' => array(
        'subgroups' => array(
          'group_page' => array(
            'subscribe_flag' => array(
              'group_type' => 'node',
            ),
            'add_content_link' => array(
              'bundles' => array('closed_group', 'group'),
              'areas' => array('header'),
            ),
          ),
        ),
      ),
    ),
  );
}

