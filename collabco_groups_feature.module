<?php
/**
 * @file
 * Code for the Collabco Groups Feature feature.
 */

include_once 'collabco_groups_feature.features.inc';

/**
 * Implements hook_menu().
 */

function collabco_groups_feature_menu() {
  $items['node/%/taxonomy/%/add'] = array(
    'page callback' => 'collabco_groups_feature_term_add_page',
    'page arguments' => array(3),
    'access callback' => 'collabco_groups_feature_term_add_access',
    'access arguments' => array(3),
  );
  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function collabco_groups_feature_menu_alter(&$items) {
  unset($items['node/%node/view']['title']);
  $items['node/%node/view']['title callback'] = 'collabco_groups_feature_view_tab_title';
  $items['node/%node/view']['title arguments'] = array(1);
}

function collabco_groups_feature_view_tab_title($node) {
  switch ($node->type) {
  case 'group':
  case 'closed_group':
  case 'project':
    return t('About');
    break;
  }
  return t('View');
}

/**
 * Implements hook_init().
 * 
 * Set og context from url query, if its being used with entity prepopulate.
 */
function collabco_groups_feature_init() { 
  $params = drupal_get_query_parameters();
  if (!empty($params[OG_AUDIENCE_FIELD])) {
    $group = node_load($params[OG_AUDIENCE_FIELD]);
    og_context('node', $group);
  }
  // Add OG Context for all subpaths of nodes that are groups.
  // Some ugly code to get the group id from path and set og_context.
  // @todo find a better way to do this, why is there no nicer drupal function?? 
  // why dosn't OG do this by default?
 
  // Check if the current path starts with /node/*.
  if ((arg(0) === 'node') && is_numeric(arg(1))) {
    // Load the node from the current path.
    if ($group = node_load(arg(1))) {
      // Check if this is a group node.
      if (!empty($group->group_group['und'][0]['value'])) {
        if ($group->group_group['und'][0]['value'] === '1') {
        // Set the og context to the group node from the path.
          og_context('node', $group);
        }
      }
    }
  }
}

/**
 * Provide users with a term add page.
 *
 * @return array
 *   A Drupal build array.
 */
function collabco_groups_feature_term_add_page($bundle) {
  if ($vocabulary = taxonomy_vocabulary_machine_name_load($bundle)) {
    module_load_include('inc', 'taxonomy', 'taxonomy.admin');
    //Build taxonomy form.
    drupal_set_title($title = t('Add ') . $vocabulary->name, $output = CHECK_PLAIN);
    $form_id = 'taxonomy_form_term';
    $edit = array();
    $form = drupal_get_form($form_id, $edit, $vocabulary);
    return drupal_render($form);
  }
  else {
    return MENU_NOT_FOUND;
  }
}

/**
 * Check access permission to term add page.
 *
 * @return bool
 */
function collabco_groups_feature_term_add_access($bundle) {
  if ($vocabulary = taxonomy_vocabulary_machine_name_load($bundle)) {
    $perm_string = "edit terms in " .  $vocabulary->vid;
    return user_access($perm_string);
  }
  else {
    return TRUE;
  }
}

/**
 * Implements hook_block_info().
 */
function collabco_groups_feature_block_info() {
  $blocks = array(
    'group_toolbar' => array(
      'info' => t('Group Toolbar'),
    ),
    'group_header' => array(
      'info' => t('Group Header'),
    ),
    'user_groups_list' => array(
      'info' => t('User Groups List)'),
    ),
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function collabco_groups_feature_block_view($delta='') {
  global $base_url;
  switch($delta) {
    case 'group_toolbar' :
      $block = collabco_groups_feature_build_group_toolbar();
      return $block;
    case 'group_header' :
      $block = collabco_groups_feature_build_group_header();
      return $block;
    case 'user_groups_list' :
      $block = collabco_groups_feature_build_user_groups_list();
      return $block;
  }

} 

/**
 * Build a group list block.
 *
 * @return array
 *   A Drupal build array.
 */
function collabco_groups_feature_build_user_groups_list() {
  global $base_url;
  global $user;
  $block = array();

  // Build groups section.
  $group_links = array();
  $groups = og_get_groups_by_user($user);
  if (!empty($groups)) {
    $block['content'] = array(
      '#type' => 'container',
      '#attributes' => array('class' => array('group-list')),
      'title' => array(
        '#type' => 'markup',
        '#markup' => 'Your Groups',
        '#weight' => 0,
        '#prefix' => '<h5>',
        '#suffix' => '</h5>'
      ),
      'group_list' => array(
        '#theme' => 'item_list',
        '#weight' => 2,
      ),
    );
    foreach ($groups['node'] as $key => $gid) {
      $node = node_load($gid);
      // Replace this with render arrays...
      $url ='node/' . $node->nid; 
      $block['content']['group_list']['#items'][$node->nid] = l($node->title, $url);
    }
  }
  return $block;
} 

/**
 * Build a group toolbar block.
 *
 * @return array
 *   A Drupal build array.
 */
function collabco_groups_feature_build_group_toolbar() {
  global $user;

  // Check if the current user is in the current group from context.
  $group = og_context();
  $entity_type = 'user';
  if (empty($group) or !og_is_member($group['group_type'], $group['gid'], $entity_type, $user)) {
    return;
  }
  $block['og_context'] = $group;

  // Create the list off links for each node type that the user can add to the
  // group. 
  $group_field_info = field_info_field(OG_AUDIENCE_FIELD);
  if (!empty($group_field_info)) {
    // Build render array structure.
    $block = array();
    $content = array(
      '#type' => 'container',
      '#attributes' => array('class' => array('group-toolbar')),
      'content' => array(
        '#type' => 'markup',
        '#markup' => t('Add content to this group:'),
        '#weight' => 0,
      ),
      'add-content-list' => array(
        '#theme' => 'item_list',
        '#weight' => 1,
      ),
      'add-term-list' => array(
        '#theme' => 'item_list',
        '#weight' => 2,
      ),
    );

    // Build query array for entity reference prepoluate
    $query_array = array(OG_AUDIENCE_FIELD => $group['gid']);
    $options = array('query' => $query_array);

    // Add a list item for each node type, as a link to its node/add page.
    foreach($group_field_info['bundles']['node'] as $bundle) {
      // Construct permission name string for the node bundle.
      $perm_string = "create $bundle content";
      // Add menu link if the current user can create nodes in the bundle.
      if (user_access($perm_string)) {
        $text = t('Create ') . node_type_get_name($bundle);
        $url = "node/add/" . str_replace('_', '-', $bundle);
        $content['add-content-list']['#items'][$bundle] = l($text, $url, $options); 
      }
    }

    // Add a list item for each taxonomy vocabulary, as a link to its term/add
    // and vocabulary view.
    foreach($group_field_info['bundles']['taxonomy_term'] as $bundle) {
      $vocabulary = taxonomy_vocabulary_machine_name_load($bundle);
      // Construct permission name string for the taxonomy bundle.
      $perm_string = "edit terms in " .  $vocabulary->vid;
      // Add menu link if the current user can create taxonomy terms in the bundle.
      if (user_access($perm_string)) {
        $text = t('Add ') . $vocabulary->name;
        $url = "node/{$group['gid']}/taxonomy/$bundle/add/";
        $content['add-term-list']['#items'][$bundle] = l($text, $url, $options); 
        // Link to view to edit all terms in vocab and group.
        $text = t('View ') . $vocabulary->name . ' ' . t('vocabulary');
        $url = "node/{$group['gid']}/taxonomy/$bundle/";
        $content['add-term-list']['#items']["edit-$bundle"] = l($text, $url); 
      }
    }
    $block['content'] = $content;
    return $block;
  }
}

/**
 * Build a group header block.
 *
 * @return array
 *   A Drupal build array.
 */
function collabco_groups_feature_build_group_header() {
  $context = og_context();
  if (empty($context)) {
    return;
  }
  $node = node_load($context['gid']);

  // Get group title and all parent group titles.
  $title = collabco_groups_feature_get_title_recursive($node);

  // Determine group privacy status.
  if (!empty($node->group_access['und'][0]['value']) && $node->group_access['und'][0]['value'] === '1') {
    $privacy = t('Private');
  }
  else {
    $privacy = t('Public');
  }

  // Build field values for the render array.

  // Build the description (body) field.
  $description = field_view_field('node', $node, 'body', array(
    'type' => 'text_summary_or_trimmed',
    'label'=>'hidden',
    'settings'=>array('trim_length' => 150),
  ));
  $description['#weight'] = '2';

  // Build the group subscribe field.
  $group_field = field_view_field('node', $node, 'group_group', array(
    'type' => 'og_group_subscribe',
    'label'=>'hidden',
  ));
  $group_field['#weight'] = '4';


  // Build render array structure.
  $block = array();
  $block['content'] = array(
    '#type' => 'container',
    '#attributes' => array('class' => array('group-header')),
    'title' => array(
      '#type' => 'markup',
      '#markup' => $title,
      '#weight' => 0,
      '#prefix' => '<div>',
      '#suffix' => '</div>'
    ),
    'description' => $description,
    'group' => $group_field,
    'status' => array(
      '#type' => 'markup',
      '#markup' => $privacy,
      '#weight' => 8,
      '#prefix' => '<div>',
      '#suffix' => '</div>'
    ),
  );

  return $block;
}

function collabco_groups_feature_get_title_recursive($group) {
  $title = l($group->title,"node/{$group->nid}");
  if (empty($group->{OG_AUDIENCE_FIELD}['und'][0]['target_id'])) {
    return $title;
  }
  $group_parent = node_load($group->{OG_AUDIENCE_FIELD}['und'][0]['target_id']);
  return collabco_groups_feature_get_title_recursive($group_parent) . ' > ' . $title;
}

function collabco_groups_feature_get_parent_recursive($group) {
  if (empty($group->{OG_AUDIENCE_FIELD}['und'][0]['target_id'])) {
    return $group;
  }
  $group_parent = node_load($group->{OG_AUDIENCE_FIELD}['und'][0]['target_id']);
  return collabco_groups_feature_get_parent_recursive($group_parent);
}

/**
 * Get all child groups, currently only nodes.
 *
 * @return array of group ids.
 */
function collabco_groups_feature_get_children_recursive($gids) {
  // Get children of all passed gids.
  $entity_type = 'node';
  if (!empty($gids[$entity_type])) {
    $result = db_query('SELECT b.gid, b.group_type
    FROM og_membership a, og_membership b
    WHERE a.gid IN (:gids)
    AND a.etid = b.gid 
    AND b.group_type = :entity_type',
    array(':entity_type' => $entity_type, ':gids' => $gids[$entity_type]));
    foreach ($result as $record) {
      $child_gids[$record->group_type][$record->gid] = $record->gid;
    }
  }
  if (empty($child_gids)) {
    return array();
  }
  $grandchild_gids = collabco_groups_feature_get_children_recursive($child_gids);
  return array_merge($child_gids, $grandchild_gids);
}

function collabco_groups_feature_preprocess_page(&$vars) {
  $vars['show_title'] = TRUE; // so that showtitle is true by default
  if (isset($vars['node'])) {
    if ($vars['node']->type == 'project') { 
      $vars['show_title'] = FALSE;
    }
  }
}

/**
 * Implements hook_entity_insert().
 * 
 * Add new subgroup gid to group terms.
 */
function collabco_groups_feature_entity_insert($entity,$type) { 
  switch ($type) {
  case 'node':
    collabco_groups_feature_add_parent_members($entity,$type);
    break;
  case 'taxonomy_term':
    collabco_groups_feature_add_child_groups_to_entity($entity,$type);
    break;
  }
}

function collabco_groups_feature_add_child_groups_to_entity($entity,$type) { 
  // Recursive function needs an array of gids by entity type.
  $wrapper = entity_metadata_wrapper($type, $entity);
  $gids = array('node' => $wrapper->{OG_AUDIENCE_FIELD}->raw()); 
  $child_gids = collabco_groups_feature_get_children_recursive($gids);
  if (empty($child_gids['node'])) { 
    return;
  }
  $values = array(
    'entity_type' => $type, 
    'entity' => $entity, 
    'field_name' => OG_AUDIENCE_FIELD, 
    'state' => OG_STATE_ACTIVE,
  );
  foreach ($child_gids['node'] as $gid) {
    og_group('node', $gid, $values);
    //$wrapper->{OG_AUDIENCE_FIELD}[] = $gid;
  }
}

function collabco_groups_feature_add_parent_members($entity,$type) { 
  // Only look at groups.
  if (empty($entity->group_group['und'][0]['value']) || ($entity->group_group['und'][0]['value'] !== 1)) {
    return;
  }
  // And only look at subgroups.
  if (empty($entity->{OG_AUDIENCE_FIELD}['und'][0]['target_id'])) {
    return;
  }

  //$base_group = collabco_groups_feature_get_parent_recursive($node);
  // Find all taxonomy terms in the group.
  //$gid = $base_group->nid;
  $parent_gid = $group->{OG_AUDIENCE_FIELD}['und'][0]['target_id'];
  $etids = collabco_groups_feature_get_group_entities('taxonomy_term', $parent_gid); 
  // Add all terms from the parent group to the newly created group.
  // This should be done directly with og_group to skip the load/save.
  $terms = entity_load('taxonomy_term', $etids);
  foreach ($terms as $term) {
    $term->{OG_AUDIENCE_FIELD}['und'][]['target_id'] = $node->nid;
    taxonomy_term_save($term);
  }
}

function collabco_groups_feature_get_group_entities($entity_type, $bundle, $gid) { 
  $query = db_select('og_membership', 'm')
  ->fields('m', array('etid'))
  ->condition('entity_type', $entity_type, '=')
  ->condition('entity_type', $entity_type, '=')
  ->condition('state', OG_STATE_ACTIVE, '=')
  ->condition('gid', $gid, '=');
  $result = $query->execute();

  $etids = array();
  foreach ($result as $row) {
    $etids[] = $row->etid;
  }
  return $etids;
}
